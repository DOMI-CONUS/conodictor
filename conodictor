#!/usr/bin/env python3

import argparse
from Bio import SearchIO
from collections import Counter
from distutils.spawn import find_executable
import gzip
from heapq import nsmallest
from matplotlib import pyplot as plt
import os
import pandas as pd
import pathlib
import platform
import pyfastx
import re
import shutil
import subprocess
import sys
from datetime import datetime

AUTHOR  = 'Anicet Ebou <anicet.ebou@gmail.com>'
URL     = 'https://github.com/koualab/conodictor.git'
VERSION = '2.0'

# Define start time
startime = datetime.now()
helptime = datetime.now().strftime("%a, %d %b %Y %H:%M:%S")

# Define command-line arguments
parser = argparse.ArgumentParser(
    prog            = 'conodictor',
    formatter_class = argparse.RawDescriptionHelpFormatter,
    usage           = 'conodictor [options] seqs.fa',
    description     = 'ConoDictor predict conopeptides superfamily using PSSMs and HMMs.',
    epilog          = f"Version:   2.0\nLicence:   GPL-3\nHomepage:  https://github.com/koualab/conodictor\nAuthor:    Anicet Ebou <anicet.ebou@gmail.com>\nLast Run:  {helptime}.")

parser.add_argument('seqs',    help    = 'Specify input sequences fasta file')
parser.add_argument('--out',   type    = pathlib.Path, default = 'conoDictor', help = 'Specify Output directory')
parser.add_argument('--force', action  = 'store_true', help = 'Force re-use output directory')
parser.add_argument('--quiet', action  = 'store_true', help = 'Decrease program verbosity')
parser.add_argument('--debug', action  = 'store_true', help = 'Activate debug mode')

args = parser.parse_args()

def main():
    # handling db directory path specification
    try:
        dbdir = os.environ['CONODB']
    except KeyError:
        msg('Databases files needed for classification not found in $PATH. Please set CONODB environment variable to the path where the HMMs and PSSMs are stored.')
        sys.exit(1)
    

    # Handling output directory creation-------------------------------------
    if os.path.isdir(args.out):
        if args.force:
            msg(f'Reusing outdir {args.out}')
            shutil.rmtree(args.out)
            os.mkdir(args.out)
        else:
            raise NameError(
        'Default folder (conoDictor) already exist!. Please change it using --out option or use --force to reuse it.')
    else:
        msg(f'Creating output directory {args.out}')
        os.mkdir(args.out)

    try:
        user = os.environ['USER']
    except KeyError:
        user = 'not telling me who you are'

    # Start program ---------------------------------------------------------
    msg(f'This is conodictor {VERSION}')
    msg(f'Written by {AUTHOR}')
    msg(f'Available at {URL}')
    msg(f"Localtime is {datetime.now().strftime('%H:%M:%S')}")
    msg(f'You are {user}')
    msg(f'Operating system is {platform.system()}')

    # Verify presence of needed tools ---------------------------------------
    needed_tools = ('hmmsearch', 'pfsearch', 'ps_scan.pl')
    
    for tool in needed_tools:
        if find_executable(tool) is not None:
            msg(f'Found {tool}')
        else:
            print_install_tool(tool)
    

    # Getting version of tools ----------------------------------------------
    sub_hmmsearch = subprocess.run(['hmmsearch', '-h'], capture_output=True)
    hmmsearch_match = re.findall(r'# HMMER\s+(\d+\.\d+)', sub_hmmsearch.stdout.decode('utf-8'))

    sub_pfsearch = subprocess.run(['pfsearch', '-h'], capture_output=True)
    pfsearch_match = re.findall(r"pfsearch\s+(\d+\.\d+ revision\s+\d\.\w)", sub_pfsearch.stderr.decode('utf-8'))
    
    sub_psscan = subprocess.run(['ps_scan.pl', '-h'], capture_output=True)
    psscan_match = re.findall(r'ps_scan version\s+(\d+\.\d+)', sub_psscan.stdout.decode('utf-8'))


    # Check that version ----------------------------------------------------
    if hmmsearch_match[0] and float(hmmsearch_match[0]) > 3:
        hmmsearch_version = hmmsearch_match[0]
    elif hmmsearch_match[0] and float(hmmsearch_match[0]) < 3:
        raise ValueError('hmmsearch installed is below 3.0 version, please upgrade.')

    else:
        raise ValueError('Cannot parse HMMER version. Please check it is correctly installed')

    
    # Read sequence file ----------------------------------------------------
    msg('Creating index of your fasta file')
    infa = pyfastx.Fasta(args.seqs)
    msg('Done creating fasta index')

    # Output some nice infos
    if infa.is_gzip:
        gzip = 'gzip compressed'
    else:
        gzip = 'not gzip compressed'
    msg(f'Your file is {gzip}')

    # Get sequence keys
    msg('Launching HMM and PSSM prediction')
    seqids = infa.keys()

    # Preparing output file
    outfile = open(f'{args.out}/summary.txt', 'a')
    outfile.write('sequence\thmm_pred\tpssm_pred\tdefinitive_pred\n')
 
    for seq in seqids:
        # Write seq on file
        with open(f'{args.out}/test.fa', 'w') as f:
            f.write(f">{seq}\n{infa[seq]}")
        f.close()

        # HMMs ---------------------------------------------------------------
        hmmclass = {}
        score = {}
        for hmmfile in os.listdir('db/HMM'):
            subprocess.run([f"hmmsearch -o {args.out}/test.hmmer {os.path.join(dbdir,'HMM',hmmfile)} {args.out}/test.fa"], shell = True)
            with open(f'{args.out}/test.hmmer', 'r') as hmmdle:
                for record in SearchIO.parse(hmmdle, 'hmmer3-text'):
                    fam = record.id.split('_')[1]
                    hits = record.hits
                    if hits:
                        for hit in hits:
                            score[record.id] = hit.evalue
                    else:
                        score[record.id] = 1
                
            hmmdle.close()
            
            # Calculate probablilty for HMMs
            phmm = 1
            for val in score.values():
                phmm *= val

            hmmclass[fam] = phmm
        
        
        # PSSMs -------------------------------------------------------------
        nm_pssm = []
        for pssmfile in os.listdir('db/PSSM'):
            subprocess.run([f"ps_scan.pl -w pfsearch -o pff -d {os.path.join(dbdir, 'PSSM', pssmfile)} {args.out}/test.fa > {args.out}/test.pssm"], shell = True)
            if os.stat(f'{args.out}/test.pssm').st_size != 0:
                pssm_res = pd.read_table(f'{args.out}/test.pssm')

                # Extracting list of matched profiles
                matched_pssm = pssm_res[pssm_res.columns[3]].tolist()
                nm_pssm = [x.split('_')[1] for x in matched_pssm]
            else:
                pass
        
        outfile.write(f"{seq}\t{get_hmm_class(hmmclass)}\t{get_pssm_class(nm_pssm)}\t{give_conodictor_class(get_hmm_class(hmmclass), get_pssm_class(nm_pssm))}\n")
        
    msg('Done with HMM and PSSM prediction.')
    outfile.close()

    # Finishing -------------------------------------------------------------
    os.remove(f'{args.out}/test.hmmer')
    os.remove(f'{args.out}/test.pssm')
    os.remove(f'{args.out}/test.fa')
    
    msg('Classification finished succesfuly.')
    msg('Creating donut plot')
    donut_graph()
    msg('Done creating donut plot')

    msg(f'Check {args.out} folder for results')
    endtime = datetime.now()
    walltime = endtime - startime
    msg(f'Walltime used (hh:mm:ss.ms): {walltime}')
    if 2021 % 2:
        msg('Nice to have you. Share, enjoy and come back!')
    else:
        msg('Thanks you, come again.')

        


# Functions -----------------------------------------------------------------
def donut_graph():
    """
    Make a donut graph from output file.
    """
    data = pd.read_table(f'{args.out}/summary.txt')
    plot_data = data[data.columns[3]].tolist()
    data_count = Counter(plot_data)
    labels = []
    for k, v in data_count.items():
        labels.append(f'{k}: {v}')
    values = [x for x in data_count.values()]

    # White circle
    blank_circle = plt.Circle((0, 0), 0.5, color = 'white')

    # Give color names
    plt.pie(values, labels = labels, wedgeprops = {'linewidth': 3, 'edgecolor': 'white'})
    p = plt.gcf()
    p.gca().add_artist(blank_circle)
    plt.savefig(f'{args.out}/superfamilies_distribution.png', dpi = 300)


def give_conodictor_class(hmmclass, pssmclass):
    """
    Gives definitive classification by combining HMM and PSSM
    classification.
    """
    deffam = None
    if hmmclass == pssmclass:
        deffam = hmmclass
    elif hmmclass == 'UNKNOWN' and pssmclass != 'UNKNOWN':
        deffam = pssmclass
    elif pssmclass == 'UNKNOWN' and hmmclass != 'UNKNOWN':
        deffam = hmmclass
    elif pssmclass and hmmclass == 'UNKNOWN':
        deffam == 'UNKNOWN'
    elif 'CONFLICT' in pssmclass and 'CONFLICT' in hmmclass:
        fams_pssm = re.search('(?<=CONFLICT)(.*)and(.*)', pssmclass)
        fams_hmm = re.search('(?<=CONFLICT)(.*)and(.*)', hmmclass)
        deffam = f'CONFLICT {fams_pssm.group(1)}, {fams_pssm.group(2)}, {fams_hmm.group(1)}, and {fams_hmm.group(2)}'
    elif 'CONFLICT' in pssmclass and not 'CONFLICT' in hmmclass:
        deffam = hmmclass
    elif 'CONFLICT' in hmmclass and not 'CONFLICT' in pssmclass:
        deffam = pssmclass
    elif pssmclass != hmmclass:
        deffam = f'CONFLICT {hmmclass} and {pssmclass}'
    
    return deffam


def get_pssm_class(mylist):
    """
    Takes a list: [A, A, B, D] and return 
    the final classification
    """
    x = Counter(mylist)
    # Take the top 2 item with highest count in list
    possible_fam = x.most_common(2)
    
    if len(possible_fam) == 1:
        fam = possible_fam[0][0]
    elif len(possible_fam) > 1:
        if possible_fam[0][1] == possible_fam[1][1]:
            fam = f'CONFLICT {possible_fam[0][0]} and {possible_fam[1][0]}'
        elif possible_fam[0][1] > possible_fam[1][1]:
            fam = possible_fam[0][0]
        else:
            fam = possible_fam[1][0]
    elif len(possible_fam) == 0:
        fam = 'UNKNOWN'
    
    return fam


def get_hmm_class(mydict):
    """
    Takes a dict: {'A': 0.023123, 'B': 0.23233} and return 
    they key of the item with the value 100 times lower than
    any other value in dict 
    """
    conofam = None
    nonzerodict = {}

    for key, value in mydict.items():
        if value != 1:
            nonzerodict[key] = value

    # If dict has only one item, then returning the key of that item
    if len(nonzerodict) == 1:
        conofam = next(iter(nonzerodict))
    else:
        # Finding the two smallest values in dict value
        two_smallest = nsmallest(2, nonzerodict.values())
        if two_smallest[0] == 0 and two_smallest[1] == 0:
            conofam = 'UNKNOWN'
        elif two_smallest[0]*100 == two_smallest[1]:
            value1 = list(mydict.keys())[list(mydict.values()).index(two_smallest[0])]
            value2 = list(mydict.keys())[list(mydict.values()).index(two_smallest[1])]
            conofam = f'CONFLICT {value1} and {value2}'
        else:
            conofam = list(mydict.keys())[
                list(mydict.values()).index(two_smallest[0])
                ]
    
    return conofam


def print_install_tool(tool):
    """
    Print useful installation instruction for required tools
    """
    if tool == 'hmmsearch':
        msg(f'{tool} not found. Please visit https://hmmer3.org.')
    elif tool == 'pfsearch' or tool == 'ps_scan.pl':
        msg(f'{tool} not found. Please visit https://github.com/sib-swiss/pftools3.')
    
    sys.exit(1)


def msg(text):
    """
    Produce nice message and info output on terminal
    """
    t = datetime.now().strftime("%H:%M:%S")
    line = f"[{t}] {text}"
    if not args.quiet:
        print(line, file = sys.stderr)


def exception_handler(exception_type, exception, traceback, debug_hook = sys.excepthook):
    """
    Remove default debug info and traceback from python output on command line.
    Use program --debug option to re-enable default behaviour. 
    """
    if args.debug:
        debug_hook(exception_type, exception, traceback)
    else:
        msg(f'{exception_type.__name__}, {exception}')

sys.excepthook = exception_handler


if __name__ == '__main__':
    main()